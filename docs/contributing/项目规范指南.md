# 项目规范指南

本文档定义了本项目的文档规范与代码规范，旨在确保代码的可维护性、可读性与团队协作效率。所有贡献者在开发过程中应遵循本规范。

---

## 文档规范

### 写作风格

技术文档应当像一篇好文章那样流畅自然。我们更倾向于使用分段的说明性文字，而非冰冷的条目堆砌。当需要表达因果关系或阐述设计决策时，完整的句子比编号列表更能传达清晰的逻辑。

例如，当解释一个模块的设计初衷时，不要写成：

> 1. 支持多种嵌入模型
> 2. 异步执行
> 3. 缓存机制

而应该这样表述：

> 嵌入模块的设计目标是同时支持云端 API 与本地模型。考虑到嵌入计算可能阻塞主线程，我们采用了异步执行的方式，将计算任务放入线程池。为了减少重复请求的开销，模块内置了可选的缓存机制，对于相同文本的嵌入结果会直接从缓存返回。

这种写法更容易让新加入的开发者理解"为什么这样设计"，而不仅仅是"这里有什么功能"。

### 目录结构

项目文档按功能分区组织，以 `docs/README.md` 为入口，目录结构如下（与仓库实际一致）：

```
docs/
├── README.md
├── requirements.md
├── frontend-api-architecture-interaction.md
├── architecture/                 # 系统架构与设计决策
│   ├── README.md
│   ├── project-design-document.md
│   ├── system-overview.md
│   ├── component-design.md
│   ├── legacy-architecture.md
│   ├── decoupled-architecture-spec.md
│   └── react-layered-architecture.md
├── api/                          # 接口文档
│   ├── README.md
│   ├── authentication.md
│   ├── course-management.md
│   ├── ai-services.md
│   ├── simulation-services.md
│   └── legacy-api.md
├── ai/                           # AI 相关技术文档
│   └── graph-rag.md
├── deployment/                   # 部署与运维
│   ├── README.md
│   └── quick-start.md
├── development/                  # 开发文档
│   ├── README.md
│   └── legacy-dev.md
├── specs/                        # 规划/方案草案
│   └── announcement-attendance-stats-plan.md
└── contributing/                 # 贡献指南
    ├── 项目规范指南.md
    └── 模块设计文档模板.md
```

### 仓库结构（规划）

仓库以 `code/` 为**唯一可执行代码入口**，其余顶层目录用于文档与学术材料。历史或临时目录需标注 `legacy` 并给出迁移计划。

```
/
├── code/                         # 代码主目录
│   ├── backend/                  # Go 后端
│   ├── ai_service/               # Python AI 服务
│   ├── simulation/               # Python 仿真服务
│   ├── frontend/                 # Vue 前端（企业微信 H5）
│   ├── frontend-react/           # React 前端（如需）
│   ├── shared/                   # 共享资源与配置
│   ├── deployment/               # 代码层部署配置
│   ├── scripts/                  # 构建与运维脚本
│   └── data/                      # 开发用数据样本
├── docs/                         # 技术文档
├── data/                         # 数据集与示例数据
├── academic/                     # 学术材料与论文
├── hust-undergrad-thesis/        # 本科论文模板与示例
├── tests/                        # 仓库级测试与一致性校验
├── assets/                       # 图表、素材与模板
├── frontend-React/               # 历史前端目录（标注 legacy 并迁移）
└── deployment/                   # 项目级部署文件（若需保留）
```

### 文档模板

每篇技术文档应当包含以下要素，但不必机械地按照固定格式填充。核心是让读者快速理解文档的目的、背景与使用方式。

**开篇说明**：用一两段话解释这个模块或功能解决什么问题，为什么需要它。这部分最重要，是读者决定是否继续阅读的依据。

**核心概念**：如果涉及领域特定的术语或设计模式，在这里做简要解释。帮助背景不同的读者建立共同的理解基础。

**使用方式**：通过清晰的代码示例展示如何使用该模块。示例应当是可运行的、有意义的，而不是过于简化的 `foo()` 和 `bar()`。

**设计考量**：解释关键的设计决策及其背后的权衡。这部分对于维护者尤其重要——当未来需要修改时，了解当初为什么这样做可以避免引入回归问题。

**注意事项**：已知的限制、边界条件、常见错误及其解决方法。

---

## 代码规范

### 设计原则

本项目遵循以下核心设计原则，它们共同构成了代码组织的基础：

**模块化与关注点分离**。每个模块应当只做一件事，并把它做好。一个理想的模块可以被独立理解、独立测试、独立替换。当你发现一个模块的职责描述需要用"和"连接时，通常意味着它应该被拆分。

**显式优于隐式**。配置项应当通过环境变量或配置文件显式指定，而不是硬编码在代码中。依赖关系应当通过构造函数或工厂函数显式注入，而不是在模块内部隐式创建。这使得代码的行为更加可预测，也更容易测试。

**防御性编程**。在模块边界处进行输入校验，对外部依赖的调用做好异常处理。错误信息应当包含足够的上下文，让调试者能够快速定位问题。

**日志与可观测性**。关键操作应当记录日志，便于事后排查。日志级别要恰当：调试信息用 DEBUG，正常流程用 INFO，异常情况用 WARNING 或 ERROR。

### Python 代码规范

Python 代码遵循 PEP 8 风格指南，并在此基础上做了一些项目特定的约定。

**命名约定**。类名使用 PascalCase，如 `EmbeddingProvider`、`VectorStore`。函数和变量使用 snake_case，如 `build_rag_context`、`chunk_text`。常量使用 UPPER_SNAKE_CASE，如 `DEFAULT_TOP_K`、`MAX_CONTEXT_CHARS`。私有成员以单下划线开头，如 `_load_index`。

**类型注解**。所有公开函数都应当添加类型注解。这不仅帮助 IDE 提供更好的补全，也让代码的意图更加清晰。对于复杂类型，可以使用 `typing` 模块或 `TypedDict` 来定义。

```python
from typing import Optional, List
from dataclasses import dataclass

@dataclass
class RetrievalContext:
    """检索上下文，携带 ACL 过滤信息。"""
    query: str
    course_id: str
    user_id: Optional[str] = None
    user_role: str = "student"
    
    def get_filters(self) -> dict:
        """根据用户角色返回过滤条件。"""
        filters = {"course_id": self.course_id}
        if self.user_role == "student" and self.user_id:
            filters["user_id"] = self.user_id
        return filters
```

**模块组织**。每个 Python 文件应当有一个清晰的主题。文件开头是模块级文档字符串，说明这个模块的用途。然后是导入语句，按标准库、第三方库、本地模块的顺序分组。接下来是常量定义、类定义、函数定义。

**异步代码**。当与外部服务交互时，优先使用异步接口以避免阻塞事件循环。如果底层库只提供同步接口，使用 `asyncio.to_thread()` 或 `asyncio.get_running_loop()` 进行包装。

```python
async def embed_text(self, text: str) -> List[float]:
    """
    异步获取文本嵌入向量。
    
    由于嵌入计算可能耗时较长，这里将计算任务放入线程池执行，
    避免阻塞 FastAPI 的事件循环影响其他请求的处理。
    """
    return await asyncio.to_thread(self._embed_sync, text)
```

**错误处理**。使用自定义异常类来表达业务错误，并在适当的层级进行捕获和转换。API 层应当将内部异常转换为用户友好的错误响应。

```python
class GraphRAGError(Exception):
    """GraphRAG 模块的基础异常类。"""
    pass

class IndexNotFoundError(GraphRAGError):
    """索引文件不存在或无法加载。"""
    pass

class RetrievalError(GraphRAGError):
    """检索过程中发生错误。"""
    pass
```

### Go 代码规范

Go 代码遵循官方的 Effective Go 指南和 Go Code Review Comments。

**项目结构**。后端采用分层架构，各层职责明确：

```
internal/
├── handler/       # HTTP 请求处理，参数校验，响应格式化
├── service/       # 业务逻辑实现
├── repository/    # 数据访问层
├── model/         # 数据模型定义
├── middleware/    # 中间件（认证、日志、限流）
└── pkg/           # 可复用的工具包
```

**错误处理**。Go 的错误处理应当遵循"向上传递，尽早返回"的原则。在错误发生的地方添加上下文信息，便于追踪错误链。

```go
func (s *CourseService) GetCourse(ctx context.Context, id string) (*model.Course, error) {
    course, err := s.repo.FindByID(ctx, id)
    if err != nil {
        if errors.Is(err, repository.ErrNotFound) {
            return nil, ErrCourseNotFound
        }
        return nil, fmt.Errorf("获取课程失败: %w", err)
    }
    return course, nil
}
```

**接口设计**。优先定义小而专注的接口。接口应当由使用者定义，而不是实现者。这遵循了依赖倒置原则，使得代码更容易测试和替换。

```go
// 由 service 层定义所需的 repository 接口
type CourseRepository interface {
    FindByID(ctx context.Context, id string) (*model.Course, error)
    Create(ctx context.Context, course *model.Course) error
}
```

### 前端代码规范

前端使用 Vue 3 + TypeScript，遵循 Vue 官方风格指南。

**组件设计**。每个组件应当职责单一，props 接口清晰。使用 Composition API 组织逻辑，将相关的状态和方法放在一起。

**类型定义**。为 API 响应和组件 props 定义 TypeScript 接口，充分利用类型系统的优势。

```typescript
interface ChatMessage {
  id: string
  role: 'user' | 'assistant'
  content: string
  citations?: Citation[]
  toolResults?: ToolResult[]
}

interface Citation {
  id: number
  source: string
  content: string
}
```

---

## Git 工作流规范

### 分支管理

项目采用简化的 Git Flow 模型。`main` 分支始终保持可部署状态，所有开发工作在特性分支上进行。

分支命名遵循统一格式：`<类型>/<简短描述>`。例如 `feature/hybrid-retrieval` 表示新功能，`fix/citation-display` 表示问题修复，`docs/api-reference` 表示文档更新。

### 提交信息

提交信息使用中文，格式为 `<类型>: <描述>`。类型包括：

- `feat`: 新功能
- `fix`: 问题修复
- `docs`: 文档更新
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建或工具链变更

描述应当简洁明了，说明这次提交做了什么，而不是怎么做的。例如：

```
feat: 实现混合检索的 RRF 融合算法
fix: 修复引用标注序号不连续的问题
docs: 补充 GraphRAG 接口文档
```

### 代码评审

所有合入 main 分支的代码都需要通过代码评审。评审重点包括：

- 代码是否符合本规范
- 是否有足够的测试覆盖
- 是否有清晰的文档说明
- 是否有潜在的性能或安全问题

---

## 测试规范

### 测试分类

**单元测试**验证单个函数或类的行为。这类测试应当快速、独立、可重复。对于有外部依赖的代码，使用 mock 来隔离。

**集成测试**验证多个模块之间的协作。例如测试检索模块与向量存储的交互，或者测试 API 端点的完整请求处理流程。

**端到端测试**从用户视角验证完整的功能场景。这类测试较慢，主要用于关键路径的验收。

### 测试指标（建议阈值）

以下指标为建议值，可按环境与阶段调整：

| 范畴 | 指标 | 目标 |
|------|------|------|
| 覆盖率 | 核心模块行覆盖率 | >=60% |
| 稳定性 | 关键路径用例通过率 | >=95% |
| 性能 | 非 AI API p95 响应 | <=300ms |
| 性能 | AI/仿真接口平均响应 | <=10s |
| 质量 | 引用正确率（GraphRAG） | >=85% |
| 质量 | 工具调用正确率 | >=90% |

### 标准测试流程（必执行）

该流程用于合并到 `main` 或发布前的统一测试，确保上表关键指标都有对应的数据产出与结论。流程按仓库结构展开：先做仓库一致性，再做服务级单测/集成/端到端，最后完成性能与质量评测。仅文档类变更可以跳过服务级步骤，但仍需通过仓库一致性测试。

**步骤 1：范围确认与测试矩阵**。明确受影响的模块（`code/backend`、`code/ai_service`、`code/simulation`、`code/frontend`、`code/frontend-react`、`tests/`），列出需执行的测试类型与指标；若某模块缺少测试脚本，必须在评审中说明缺口并给出补齐计划。

**步骤 2：仓库一致性测试**。运行 `tests/` 下的仓库级校验，确保目录结构、文档与迁移规则符合标准。

```bash
cd tests
npm test
```

**步骤 3：服务级单元测试与覆盖率**。对 Go 与 Python 服务执行单测并产出覆盖率报告；覆盖率是关键指标之一，不得缺失。前端当前若未配置自动化测试，至少执行构建校验作为最低保障。

```bash
cd code/backend
go test ./... -cover

cd code/ai_service
pytest -v --cov=app --cov-report=term-missing

cd code/simulation
pytest -v --cov=app --cov-report=term-missing

cd code/frontend
npm run build

cd code/frontend-react
npm run build
```

**步骤 4：集成测试**。在 Docker Compose 或开发环境下验证服务间调用与数据库交互，覆盖鉴权、课程、作业、AI 调用与仿真链路。

**步骤 5：端到端测试**。运行关键路径脚本，当前至少包含引导式学习链路。

```bash
./scripts/e2e_guided_learning.sh
```

**步骤 6：性能与质量评测**。对非 AI API p95、AI/仿真平均响应、引用正确率、工具调用正确率进行量化评测，并在测试报告中记录数据与结论。评测脚本统一放在 `scripts/` 或服务内 `tests/` 下，评测基线（样例集）需版本化管理。

**步骤 7：门槛判定**。关键指标未达标视为测试失败；如需调整阈值，必须在评审中说明原因并给出整改计划与时间表。

**关键指标覆盖映射**：

| 指标 | 归属步骤 | 采集方式 | 判定 |
|------|----------|----------|------|
| 核心模块行覆盖率 | 步骤 3 | `go test -cover` / `pytest --cov` | >=60% |
| 关键路径用例通过率 | 步骤 4-5 | 集成 + E2E 通过数/总数 | >=95% |
| 非 AI API p95 响应 | 步骤 6 | k6/wrk 压测报告 | <=300ms |
| AI/仿真接口平均响应 | 步骤 6 | 压测或采样统计 | <=10s |
| 引用正确率（GraphRAG） | 步骤 6 | 标准评测集 | >=85% |
| 工具调用正确率 | 步骤 6 | 标准评测集 | >=90% |

### 测试文件组织（按语言区分）

不同语言按各自生态放置测试用例，仓库级测试统一放在 `tests/`。

```
code/ai_service/
├── app/
└── tests/
    ├── test_retrieve.py
    └── test_embedding.py

code/backend/
└── internal/
    └── service/
        └── course_test.go

code/frontend/
└── src/
    └── __tests__/
        └── course-list.test.ts

code/frontend-react/
└── src/
    └── __tests__/
        └── task-registry.test.ts

tests/
└── overall-structure-validation.test.ts
```

### 测试用例设计

每个测试用例应当测试一个具体的行为，测试名称应当描述被测试的场景和预期结果。

```python
class TestBuildRagContextHybrid:
    """混合检索的测试套件。"""
    
    async def test_returns_citations_with_source_info(self, mock_embedding, mock_store):
        """验证返回的引用包含来源信息。"""
        result = await build_rag_context_hybrid(context, index, embedding, store)
        assert len(result.citations) > 0
        assert all(c.source for c in result.citations)
    
    async def test_filters_by_user_id_for_student_role(self, mock_embedding, mock_store):
        """验证学生角色只能检索自己的提交。"""
        context = RetrievalContext(query="...", user_role="student", user_id="123")
        result = await build_rag_context_hybrid(context, index, embedding, store)
        assert all(c.user_id == "123" for c in result.sources)
```

---

## 调试指南

### 日志配置

开发环境下，将日志级别设置为 DEBUG 可以看到详细的执行过程。生产环境使用 INFO 级别。

```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

### 常见问题排查

**检索结果为空**。首先检查索引是否已正确加载（查看启动日志）。然后验证查询文本是否与索引内容匹配。可以降低相似度阈值或增加返回数量来观察是否有潜在匹配。

**工具调用失败**。检查工具定义的 schema 是否正确。查看 LLM 返回的原始响应，确认工具调用请求的格式是否符合预期。验证工具执行器是否正常工作。

**嵌入请求超时**。检查嵌入服务是否可达。考虑增加超时时间或添加重试机制。对于高并发场景，考虑使用批量嵌入接口减少请求次数。
