\appendix

\chapter{系统接口说明}

\section{AI 服务核心接口}
表~\ref{tab:ai-api}~列出了 AI 服务层的核心 API 接口。

\begin{table}[htbp]
  \centering
  \caption{AI 服务核心接口说明}
  \label{tab:ai-api}
  \begin{tabular}{p{4cm}lp{6cm}}
    \toprule
    接口路径 & 方法 & 功能说明 \\
    \midrule
    /v1/chat/completions & POST & OpenAI-compatible 对话接口，支持 mode 选择技能，支持 \_rag 后缀启用检索增强 \\
    /v1/writing/analyze & POST & 写作样本分析，返回多维度评估结果 \\
    /v1/guided/start & POST & 创建引导式学习会话 \\
    /v1/guided/step & POST & 推进学习步骤 \\
    /v1/graphrag/index & POST & 添加或更新知识库索引 \\
    /v1/graphrag/index & DELETE & 删除指定索引条目 \\
    /health & GET & 服务健康检查 \\
    \bottomrule
  \end{tabular}
\end{table}

\section{后端业务接口}
表~\ref{tab:backend-api}~列出了后端业务层的核心 API 接口。

\begin{table}[htbp]
  \centering
  \caption{后端业务核心接口说明}
  \label{tab:backend-api}
  \begin{tabular}{p{4cm}lp{6cm}}
    \toprule
    接口路径 & 方法 & 功能说明 \\
    \midrule
    /api/auth/login & POST & 用户登录，返回 JWT Token \\
    /api/auth/register & POST & 用户注册 \\
    /api/courses & GET/POST & 课程列表获取与创建 \\
    /api/courses/:id & GET/PUT/DELETE & 单个课程的查询、更新与删除 \\
    /api/assignments & GET/POST & 作业列表与创建 \\
    /api/submissions & GET/POST & 作业提交列表与创建 \\
    /api/ai/chat & POST & AI 对话代理（转发至 AI 服务） \\
    /api/profile/course/:id & GET & 课程学习画像查询 \\
    /api/profile/global & GET & 全局学习画像查询 \\
    /api/events & GET/POST & 学习事件查询与记录 \\
    \bottomrule
  \end{tabular}
\end{table}

\chapter{关键代码片段}

\section{技能注册与路由}
以下代码展示了技能系统的注册与路由机制（Python）：

\begin{verbatim}
# skills/registry.py

SKILLS = {
    "tutor": TutorSkill(),
    "grader": GraderSkill(),
    "guided_learning": GuidedLearningSkill(),
    "writing_feedback": WritingFeedbackSkill(),
    "personalized_strategy": PersonalizedStrategySkill(),
}

# 别名映射，保证向后兼容
ALIASES = {
    "answer": "tutor",
    "explain": "tutor",
    "grade": "grader",
}

def get_skill(mode: str) -> BaseSkill:
    """根据 mode 获取技能实例，支持 _rag 后缀"""
    base_mode = mode.replace("_rag", "")
    resolved = ALIASES.get(base_mode, base_mode)
    return SKILLS.get(resolved, SKILLS["tutor"])
\end{verbatim}

\section{GraphRAG 检索流程}
以下代码展示了 GraphRAG 的混合检索与图扩展逻辑（Python）：

\begin{verbatim}
# graphrag/retrieve.py

def hybrid_retrieve(query: str, top_k: int = 5) -> List[Chunk]:
    # 1. 关键词检索
    keyword_results = keyword_search(query, top_k=top_k*2)
    # 2. 语义向量检索
    semantic_results = vector_search(query, top_k=top_k*2)
    # 3. RRF 融合排序
    fused = reciprocal_rank_fusion(
        [keyword_results, semantic_results], k=60
    )
    return fused[:top_k]

def graph_expand(chunks: List[Chunk], hops: int = 1) -> List[Chunk]:
    """从种子片段出发，沿知识图谱边扩展"""
    expanded = set(chunks)
    for chunk in chunks:
        neighbors = get_neighbors(chunk.id, max_hops=hops)
        expanded.update(neighbors)
    return list(expanded)
\end{verbatim}

\section{工具调用执行器}
以下代码展示了工具调用的执行与结果回注逻辑（Python）：

\begin{verbatim}
# tools/executor.py

TOOL_WHITELIST = {"calculate", "simulate", "check_format"}
MAX_TOOL_CALLS = 3

async def execute_tool_calls(
    tool_calls: List[ToolCall],
    context: ChatContext
) -> List[ToolResult]:
    results = []
    for i, call in enumerate(tool_calls):
        if i >= MAX_TOOL_CALLS:
            break
        if call.name not in TOOL_WHITELIST:
            results.append(ToolResult(
                call_id=call.id,
                error=f"Tool {call.name} not allowed"
            ))
            continue
        try:
            result = await TOOLS[call.name].execute(call.arguments)
            results.append(ToolResult(
                call_id=call.id,
                content=result
            ))
        except TimeoutError:
            results.append(ToolResult(
                call_id=call.id,
                error="Tool execution timed out"
            ))
    return results
\end{verbatim}

\chapter{部署指南}

\section{环境要求}
\begin{itemize}
  \item Docker 24.0 及以上
  \item Docker Compose 2.x 及以上
  \item 推理服务需 NVIDIA GPU（推荐 RTX 4090 或同级）
  \item 内存建议 32GB 以上
\end{itemize}

\section{快速部署步骤}
\begin{enumerate}
  \item 克隆代码仓库并进入 \texttt{code/} 目录
  \item 复制 \texttt{.env.example} 为 \texttt{.env} 并配置环境变量
  \item 执行 \texttt{docker-compose up -d} 启动所有服务
  \item 执行 \texttt{docker-compose logs -f} 查看日志确认启动成功
  \item 访问 \texttt{http://localhost:3000} 进入前端应用
\end{enumerate}

\section{服务端口说明}
\begin{table}[htbp]
  \centering
  \caption{服务端口分配}
  \begin{tabular}{llr}
    \toprule
    服务 & 说明 & 端口 \\
    \midrule
    frontend & React 前端 & 3000 \\
    backend & Go 后端 & 8080 \\
    ai\_service & AI 服务 & 8000 \\
    simulation & 仿真服务 & 8001 \\
    mysql & 数据库 & 3306 \\
    \bottomrule
  \end{tabular}
\end{table}
